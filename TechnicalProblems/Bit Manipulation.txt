Bit Manipulation:

& - The AND operation.
| - The OR operation.
^ - The XOR operation.
~ - The NOT operation.

Tips and Tricks:
	1. If two of the same bit values are added together, it's equal to multiplying
		one of the values by 2. In that case, just shift the bits of one of the
		values over by 1, since that is equivalent to multiplying by 2. For example,
		1001 + 1001 is equal to 2 * 1001, or 1001 << 1.
	2. If a bit value is being multiplied by a value that only has one bit set to
		1 (a 2^x value, where x is a number), shift the bit value to the right by
		x bits. For example, 1000 * 1011 is equal to 2^3 * 1011, or 1011 << 3.
	3. Any value XORed with its negated value is equal to all 1s. For example,
		1101 ^ ~1101 = 1111.
	4. Can zero out the last x bits by negating 0, shifting that result x bits to
		the right, and ANDing the result with the input bit value. For example,
		1101 & (~0 << 3) is 1000.

Other Tips and Tricks:
	1. x ^ 0000.. = x
		a. Explanation: 1 ^ 0 is 1, and 0 ^ 0 is 0, so x ^ 0000.. will just preserve
			the bits of the original value.
	2. x ^ 1111.. = ~x
		a. Explanation: 1 ^ 1 is 0, and 0 ^ 1 is 1, so x ^ 1111.. will invert each
			bit in the original value.
	3. x ^ x = 0
		a. Explanation: 1 ^ 1 is 0, and 0 ^ 0 is 0, so x ^ x will cancel each bit
			out and set it to 0.
	4. x & 0000.. = 0
		a. Explanation: Any bit AND 0 is 0, so x & 0000.. will set all bits to 0.
	5. x & 1111.. = x
		a. Explanation: 1 & 1 is 1, and 0 & 1 is 0, so x & 1111.. will not change
			any of the bits in the original value.
	6. x & x = x
		a. Explanation: 1 & 1 is 1, and 0 & 0 is 0, so x & x will not change any
			of the bits in the original value.
	7. x | 0000.. = x
		a. Explanation: 1 | 0 is 1, and 0 | 0 is 0, so x | 0000.. will not change
			any of the bits in the original value.
	8. x | 1111.. = 1111..
		a. Explanation: 1 | 1 is 1, and 0 | 1 is 1, so x | 1111.. will set all of
			the bits to 1.
	9. x | x = x
		a. Explanation: 1 | 1 is 1, and 0 | 0 is 0, so x | x will not change any
			of the bits in the original value.

/******************************************************************************/

Two's Complement and Negative Numbers:

Integers are usually stored in two's complement representation. Positive numbers 
always have their leftmost bit set to 0, while negative numbers always have their
leftmost bit set to 1. The two's complement of a number can be calculated by the
following:
	
	1. If the number is positive:
		1a. Take all of its bits besides the sign bit and negate them.
		1b. Add one to the result.
		1c. Change the sign bit to 1 to signify that it is a negative number.
	2. If the number is negative:
		2a. Take all of its bits besides the sign bit and negate them.
		2b. Subtract one from the result.
		2c. Change the sign bit to 0 to signify that it is a positive number.

Note that a number and its two's complement, when added together, will equal a
power of 2. For example, the 7 is represented as 111 without the sign bits, and
-7 is represented as 001 without the sign bits. When added together, they sum up
to 1000, or 2^3.

/******************************************************************************/

Arithmetic versus Logical Right Shift:

There are two types of right shift operators:
	1. Arithmetic Right Shift
		a. In arithmetic right shift, the leftmost bit is preserved when the rest
			of the number is shifted to the right. This operator should be used if
			dividing by 2, since the sign bit would be kept (hence, arithmetic 
			operator).
	2. Logical Right Shift
		b. In logical right shift, the leftmost bit is set to 0 when the rest of
			the number is shifted to the right. This operator should be used when
			attempting to erase bits.

int repeatedArithmeticShift(int number, int shiftCount)
{
	for(int i = 0; i < shiftCount; ++i)
	{
		number >>= 1;	/* Arithmetic shfit by 1. */
	}

	return number;
}

int repeatedLogicalShift(int number, int shiftCount)
{
	for(int i = 0; i < shiftCount; ++i)
	{
		number >>>= 1;	/* Logical shfit by 1. */
	}

	return number;
}

In the above example, placing the parameters number = -50000 and shiftCount = 40 
would result in the following:
	1. repeatedArithmeticShift would return -1, since the negative sign bit would
		propagate right, resulting in a number with all bits set to 1 by the end 
		of the loop, which is equal to -1.
	2. repeatedLogicalShift would return 0, since 0s would propagate right, resulting
		in a number with all bits set to 0 by the end of the loop.

/******************************************************************************/

Common Bit Tasks:

Get Bit: This task can be performed by shifting a bit mask of 1 over to the ith
	bit and ANDing the number and the bit mask. If the result is 0, then just
	return that value, else return 1.

int getBit(int number, int bitIndex)
{
	return (number & (1 << bitIndex)) == 0 ? 0 : 1;
}

Set Bit: This task can be performed by shifting a bit mask of 1 over to the ith
	bit. If the bit should be set to 1, then OR the bit mask with the number and
	return the result. If the bit should be set to 0, then negate the bit mask,
	AND the bit mask with the number, and return the result.

int setBit(int number, int bitIndex, bool setBit)
{
	int bitMask = setBit ? (1 << bitIndex) : ~(1 << bitIndex);
	return setBit ? (number | bitMask) : (number & bitMask);	
}

Clear Most Significant (Leftmost) Bit to ith Bit: This task can be performed by
	shifting a bit mask of 1 over i bits to the left. Then, subtract 1 from that
	mask to create 0..0 from the MSB to the ith bit, and 1..1 from the (i-1)th bit
	to the 0th bit. AND the mask and the number to clear all bits from the MSB to
	the ith bit.

int clearMSBToIth(int number, int bitIndex)
{
	return number & ((1 << bitIndex) - 1);
}

Clear ith Bit to 0th Bit: This task can be performed by shifting -1 (which is
	represented as all 1s) left i + 1 bits. This will result in the bit mask
	containing 1..1 from the MSB to the (i+1)th bit, and 0..0 from the ith bit
	to the 0th bit. AND the mask and the number to clear all bits from the ith
	bit to the 0th bit.

int clearIthTo0th(int number, int bitIndex)
{
	return number & (-1 << (bitIndex + 1));
}
Linked Lists:

A linked list is a data structure that consists of a sequence of nodes that point
to each other through pointers. In a singly-linked list, each node in the list only
points to the next node in the list. In a doubly-linked list, each node in the list
points to the previous and the next node in the list.

Note: It is crucial that you ask the interviewer whether or not the linked list
is a singly-linked list or a doubly-linked list.

Advantages of Linked Lists:
	1. A linked list has a O(1) runtime in insertion and deletion, since a few
		pointers would have to be updated at most. However, an array has a O(n)
		worst-case runtime in both insertion and deletion, since it's possible
		that an insertion at the beginning of the array would force all elements
		to shift right one spot, or a deletion at the beginning of the array would
		force all elements to shift left one spot.
	2. Unlike arrays and resizable arrays, linked lists are not contiguous in
		memory. This means that no reallocation and copying of memory is required,
		such as that in resizable arrays when they hit their size capacity.

Disadvantages of Linked Lists: 
	1. A linked list has a O(n) access time. Since the data structure is not
		contiguous in memory, the program must traverse through each node's pointers
		until it reaches its desired node. Arrays, on the other hand, have a O(1)
		access time, since they are contiguous in memory - pointer arithmetic can
		be used to access any element in the array in constant time.
	2. Given a linked list and an array that hold the same values, the linked list
		will take up more memory, since each node has at least one pointer to
		another node (and each pointer can use up 4 bytes of memory).

Contents of a Linked List:
	1. A linked list node.
		1a. The data value that the node is supposed to contain.
	2. A wrapper class that contains a pointer to the head node of the linked list.
		2a. An insertion method to add a node to the linked list.
		2b. A deletion method to delete a node from the linked list.
		2c. An access method to access a specific node.
		2d. A size method to determine how many elements exist in the linked list.
		2e. (Optional) A find method to find a node with a specific value.

Insertion of a Node into a Linked List (Singly-Linked List):
	1. Create a new node with the given data value.
	2. Start at the beginning of the linked list, traverse along the linked list
		until the desired position is found.
	3. Have the node point to the previous pointer's next node, and have the
		previous pointer point to the node.
		3a. An edge case is present if the node is to be inserted at the head of
			the linked list. The linked list's head node would need to be updated.

Deletion of a Node from a Linked List (Singly-Linked List):
	1. Scan along a linked list until the node to be deleted is found.
	2. Have the previous node point to the deleted node's next node.
		2a. An edge case is present if the node that was deleted was the head of
			the linked list. The linked list's head node would need to be updated.
	3. Delete the node.

The "Runner" Technique:

The "runner" technique involves two pointers in which one pointer is ahead of the
other pointer. This is done by either placing one pointer ahead of the other pointer
or by advancing one pointer multiple nodes for each node that the other pointer
advances.

A classic way of using the runner technique is to find the middle node of a linked
list of an unknown size. Start with two nodes at the head node; have one node
advance two nodes per iteration, and the other node advance one node per iteration.

After traversing n nodes, the faster pointer will have reached the end of the linked
list. On the other hand, since the slower pointer is half as fast as the faster
pointer, it will have only traversed n/2 nodes by the time the faster pointer reaches
the end. Thus, the slower pointer will be pointing to the middle node of the linked
list when the faster pointer reaches the end of the linked list.